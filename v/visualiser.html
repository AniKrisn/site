<!DOCTYPE html>
<html>
<head>
    <title>AV</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #controls { 
            position: fixed; 
            top: 26px; 
            left: 26px; 
            z-index: 100;
            padding: 4px;
            background: #578E7E;
            display: flex;
            flex-direction: row;
            gap: 12px;
            align-items: center;
        }
        button {
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #3D3D3D;
            color: #578E7E;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bolder;
        }
        button:hover {
            background: #525252;
        }
        button:disabled {
            background: #3D3D3D;
            cursor: not-allowed;
        }

        @media (max-width: 768px) {
            button {
                padding: 12px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="trackSwitch">1</button>
        <button id="playPause">▶</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, analyser, dataArray;
        let geometry, material, mesh;
        let audioElement = null;
        let audioContext = null;
        let lights = [];
        let backgroundScene, backgroundCamera, backgroundMesh;
        let currentTrack = 1;
        let currentVisualizer = 1;

        const track1Colors = ['#4793AF', '#FFC470', '#DD5746', '#8B322C', '#D5E7B5', '#72BAA9', '#7E5CAD', '#474E93'].map(color => new THREE.Color(color));
        const track2Colors = ['#A31D1D', '#6D2323', '#441752', '#FFD65A', '#FF9D23', '#F93827', '#16C47F', '#123524'].map(color => new THREE.Color(color));
        let colors = track1Colors;

        function switchTrack() {
            if (audioElement && !audioElement.paused) {
                fadeOut(audioElement);
                document.getElementById('playPause').textContent = '▶';
            }
            
            currentTrack = currentTrack === 1 ? 2 : 1;
            document.getElementById('trackSwitch').textContent = currentTrack;
            
            if (audioElement) {
                audioElement.src = currentTrack === 1 ? 'wt7.wav' : 'cy7.wav';
            }
            
            colors = currentTrack === 1 ? track1Colors : track2Colors;
            
            // Switch background
            backgroundScene.remove(backgroundMesh);
            backgroundMesh = backgroundMeshes[currentTrack].mesh;
            backgroundScene.add(backgroundMesh);
            
            // Reset material color
            material.color.copy(colors[0]);
            colorIndex = 0;
            targetIntensity = 0.0;
        }

        document.getElementById('trackSwitch').addEventListener('click', switchTrack);

        function createKaleidoscopeBackground() {
            backgroundScene = new THREE.Scene();
            backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);

            const fragmentShader = `
                uniform float time;
                uniform float intensity;
                uniform vec3 color1;
                uniform vec3 color2;
                uniform vec3 color3;
                uniform float aspectRatio;
                
                varying vec2 vUv;

                // Noise function
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    
                    float a = fract(sin(dot(i, vec2(12.9898, 78.233))) * 43758.5453);
                    float b = fract(sin(dot(i + vec2(1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453);
                    float c = fract(sin(dot(i + vec2(0.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);
                    float d = fract(sin(dot(i + vec2(1.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);

                    f = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, f.x) + (c - a) * f.y * (1.0 - f.x) + (d - b) * f.x * f.y;
                }
                
                void main() {
                    vec2 p = (vUv - 0.5) * 2.0;
                    p.x *= aspectRatio;  // Adjust for screen aspect ratio
                    float r = length(p);
                    float angle = atan(p.y, p.x);
                    
                    // Create 8-fold symmetry
                    float segments = 8.0;
                    angle = mod(angle + time * 0.2, 2.0 * 3.14159 / segments);
                    angle = abs(angle - 3.14159 / segments);
                    
                    // Create patterns
                    float pattern1 = sin(r * 10.0 - time) * 0.5 + 0.5;
                    float pattern2 = cos(angle * 5.0 + r * 5.0 - time * 0.5) * 0.5 + 0.5;
                    float pattern3 = sin(r * 15.0 + angle * 3.0 + time * 0.3) * 0.5 + 0.5;
                    
                    // Mix colors based on patterns
                    vec3 finalColor = mix(color1, color2, pattern1);
                    finalColor = mix(finalColor, color3, pattern2 * pattern3);
                    
                    // Create noisy fade for intensity
                    vec2 noiseCoord = p * 3.0 + time * 0.5;
                    float noiseVal = noise(noiseCoord) * 0.5 + 0.5;
                    float noisyIntensity = intensity * (0.8 + 0.2 * noiseVal);
                    
                    // Basic falloff from center
                    float falloff = 1.0 - pow(r, 1.5);
                    
                    gl_FragColor = vec4(finalColor, falloff * noisyIntensity * 0.25);
                }
            `;
        }

        
        function createSynthwaveBackground() {
            const fragmentShader = `
                uniform float time;
                uniform float intensity;
                uniform vec3 color1;
                uniform vec3 color2;
                uniform vec3 color3;
                uniform float aspectRatio;
                
                varying vec2 vUv;

                const float PI = 3.14159265359;

                float drawGrid(vec2 uv) {
                    vec2 grid = fract(uv * 40.0);
                    float lines = max(
                        smoothstep(0.02, 0.0, abs(grid.x - 0.5)),
                        smoothstep(0.02, 0.0, abs(grid.y - 0.5))
                    );
                    return lines * smoothstep(1.2, 0.0, uv.y);
                }

                float drawSun(vec2 uv, float radius) {
                    float dist = length(uv - vec2(0.5, 0.5));
                    float sun = smoothstep(radius + 0.1, radius, dist);
                    return sun;
                }

                float drawSynthLines(vec2 uv) {
                    float lines = 0.0;
                    for(float i = 0.0; i < 10.0; i++) {
                        float y = fract(uv.y * 4.0 + i * 0.1 + time * 0.2);
                        float width = 0.01 + i * 0.001;
                        lines += smoothstep(width, 0.0, abs(y - 0.5));
                    }
                    return lines * smoothstep(1.2, 0.0, uv.y);
                }

                void main() {
                    vec2 uv = vUv;
                    uv.x *= aspectRatio;

                    vec2 perspectiveUV = uv;
                    perspectiveUV.y = pow(perspectiveUV.y, 1.5);
                    
                    float sunGlow = drawSun(uv, 0.2);
                    float grid = drawGrid(perspectiveUV);
                    float synthLines = drawSynthLines(perspectiveUV);

                    vec3 finalColor = mix(color2, color1, sunGlow);
                    finalColor += color3 * grid * 0.5;
                    finalColor += color1 * synthLines;

                    float scanline = sin(uv.y * 200.0 + time * 10.0) * 0.02;
                    finalColor *= 1.0 - scanline;

                    float noise = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
                    finalColor *= 0.95 + noise * 0.05;

                    float fade = intensity * (0.5 + 0.5 * sin(time));
                    
                    gl_FragColor = vec4(finalColor, fade);
                }
            `;

            return createBackground(fragmentShader);
        }

        
        function createBackground(fragmentShader) {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    intensity: { value: 0.0 },
                    color1: { value: new THREE.Color(colors[0]) },
                    color2: { value: new THREE.Color(colors[1]) },
                    color3: { value: new THREE.Color(colors[3]) },
                    aspectRatio: { value: window.innerWidth / window.innerHeight }
                },
                fragmentShader,
                vertexShader,
                transparent: true,
                depthWrite: false
            });

            const geometry = new THREE.PlaneGeometry(4, 4);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1;
            return { mesh, material };
        }


        let targetIntensity = 0;
        let currentIntensity = 0;

        function updateBackgroundIntensity() {
            const transitionSpeed = 0.01;
            currentIntensity += (targetIntensity - currentIntensity) * transitionSpeed;
            
            if (backgroundMesh) {
                backgroundMesh.material.uniforms.intensity.value = currentIntensity;
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);
            
            backgroundScene = new THREE.Scene();
            backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);

            const kaleidoscopeBackground = createKaleidoscopeBackground();
            const synthwaveBackground = createSynthwaveBackground();

            backgroundMeshes = {
                1: kaleidoscopeBackground,
                2: synthwaveBackground
            };

            geometry = new THREE.IcosahedronGeometry(0.5, 3);
            
            material = new THREE.MeshPhongMaterial({
                color: track1Colors[0],
                flatShading: true,
                shininess: 50,
                transparent: true,
                opacity: 1.0 
            });

            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            geometry.userData = {
                originalPositions: geometry.attributes.position.array.slice()
            };

            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            for (let i = 0; i < 4; i++) {
                const light = new THREE.PointLight(track1Colors[i], 0.5, 10);
                light.position.set(
                    Math.cos(i * Math.PI/2) * 3,
                    Math.sin(i * Math.PI/2) * 3,
                    0
                );
                lights.push(light);
                scene.add(light);
            }

            camera.position.z = 4;
        }

        function initializeAudio() {
            if (!audioElement) {
                audioElement = document.createElement('audio');
                audioElement.src = 'wt7.wav';
                audioElement.style.display = 'none';
                document.body.appendChild(audioElement);

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(audioElement);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                audioElement.addEventListener('ended', function() {
                    const playPauseButton = document.getElementById('playPause');
                    playPauseButton.textContent = '▶';
                    targetIntensity = 0.0;
                });
            }
        }

        document.getElementById('playPause').addEventListener('click', function() {
            if (!audioElement) {
                initializeAudio();
            }

            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (audioElement.paused) {
                fadeIn(audioElement);
                this.textContent = '❚❚';
                targetIntensity = 1.0;
            } else {
                fadeOut(audioElement);
                this.textContent = '▶';
                targetIntensity = 0.0;
            }
        });

        let colorIndex = 0;
        let colorTransitionTime = 0;
        let time = 0;

        function getAverageFrequency() {
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            return sum / (dataArray.length * 255); 
        }

        function fadeIn(audio) {
            const fadeDuration = 0.3; 
            audio.volume = 0;
            audio.play();
            let startTime = audio.currentTime;
            const fadeInterval = setInterval(() => {
                const elapsedTime = audio.currentTime - startTime;
                audio.volume = Math.min(elapsedTime / fadeDuration, 1);
                if (audio.volume === 1) {
                    clearInterval(fadeInterval);
                }
            }, 30);
        }

        function fadeOut(audio) {
            const fadeDuration = 0.3;
            let startTime = audio.currentTime;
            const initialVolume = audio.volume;
            const fadeInterval = setInterval(() => {
                const elapsedTime = audio.currentTime - startTime;
                audio.volume = Math.max(initialVolume - (elapsedTime / fadeDuration), 0);
                if (audio.volume === 0) {
                    audio.pause();
                    clearInterval(fadeInterval);
                }
            }, 30);
        }

        function updateConstantAnimation() {
            mesh.rotation.x += 0.001;
            mesh.rotation.y += 0.002;

            if (backgroundMesh) {
                backgroundMesh.material.uniforms.time.value = time;
                const colorIndex1 = Math.floor(time * 0.1) % track1Colors.length;
                const colorIndex2 = (colorIndex1 + 1) % track1Colors.length;
                const colorIndex3 = (colorIndex2 + 1) % track1Colors.length;
                backgroundMesh.material.uniforms.color1.value = track1Colors[colorIndex1];
                backgroundMesh.material.uniforms.color2.value = track1Colors[colorIndex2];
                backgroundMesh.material.uniforms.color3.value = track1Colors[colorIndex3];
            }

            lights.forEach((light, i) => {
                const angle = time * 0.5 + (i * Math.PI/2);
                const radius = 3 + Math.sin(time) * 0.3;
                light.position.x = Math.cos(angle) * radius;
                light.position.y = Math.sin(angle) * radius;
                light.intensity = 0.5;
            });

            colorTransitionTime += 0.001;
            if (colorTransitionTime >= 1) {
                colorTransitionTime = 0;
                colorIndex = (colorIndex + 1) % track1Colors.length;
                material.color.copy(track1Colors[colorIndex]);
            }
        }


        function updateAudioReactiveAnimation() {
            if (!analyser || !dataArray) return;
            
            analyser.getByteFrequencyData(dataArray);
            const avgFreq = getAverageFrequency();

            const positions = geometry.attributes.position.array;
            const originalPositions = geometry.userData.originalPositions;

            for (let i = 0; i < positions.length; i += 3) {
                const originalX = originalPositions[i];
                const originalY = originalPositions[i + 1];
                const originalZ = originalPositions[i + 2];

                const distanceFromCenter = Math.sqrt(
                    originalX * originalX + 
                    originalY * originalY + 
                    originalZ * originalZ
                );

                const angle = Math.atan2(originalY, originalX);
                
                const wave = Math.sin(angle * 6 + time * 2) * 0.7;
                const pulse = Math.sin(distanceFromCenter * 5 - time * 3) * 0.9;
                const spiral = Math.sin(angle + distanceFromCenter * 4 + time) * 0.2;
                
                const maxDeformation = 0.7;
                const deformation = Math.max(-maxDeformation, 
                                          Math.min(maxDeformation, 
                                                 (wave + pulse + spiral) * avgFreq * 2));

                positions[i] = originalX * (1 + deformation);
                positions[i + 1] = originalY * (1 + deformation);
                positions[i + 2] = originalZ * (1 + deformation);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();

            lights.forEach(light => {
                light.intensity = 0.5 + avgFreq * 0.5 * 8;
            });

            colorTransitionTime += avgFreq * 0.1;
            if (colorTransitionTime >= 1) {
                colorTransitionTime = 0;
                colorIndex = (colorIndex + 1) % track1Colors.length;
                material.color.copy(track1Colors[colorIndex]);
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            updateBackgroundIntensity();

            renderer.clear();

            renderer.clearDepth();
            renderer.render(backgroundScene, backgroundCamera);
            
            renderer.clearDepth();

            updateConstantAnimation();
            
            if (analyser && audioElement && !audioElement.paused) {
                updateAudioReactiveAnimation();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            backgroundMesh.material.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
        }

        init();
        animate();
    </script>
</body>
</html>