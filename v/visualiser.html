<!DOCTYPE html>
<html>
<head>
    <title>AV</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #controls { 
            position: fixed; 
            top: 26px; 
            left: 26px; 
            z-index: 100;
            padding: 4px;
            background: #578E7E;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #3D3D3D;
            color: #578E7E;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #525252;
        }
        button:disabled {
            background: #3D3D3D;
            cursor: not-allowed;
        }

        .mobile-message {
            color: white;
            text-align: center;
            margin-top: 20%;
            font-family: monospace;
        }
        
    </style>
</head>
<body>
    <div id="controls">
        <button id="playPause">▶</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>

        // mobile msg
        if (window.innerWidth < 768) {
            document.body.innerHTML = '<h1 class="mobile-message">please play on pc!</h1>';
        }

        let scene, camera, renderer, analyser, dataArray;
        let geometry, material, mesh;
        let audioElement = null;
        let audioContext = null;
        let lights = [];
        let backgroundScene, backgroundCamera, backgroundMesh;

        // Color palette
        const colors = ['#4793AF', '#FFC470', '#DD5746', '#8B322C', '#D5E7B5', '#72BAA9', '#7E5CAD', '#474E93'].map(color => new THREE.Color(color));

        function createKaleidoscopeBackground() {
            backgroundScene = new THREE.Scene();
            backgroundCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);

            const fragmentShader = `
                uniform float time;
                uniform float intensity;
                uniform vec3 color1;
                uniform vec3 color2;
                uniform vec3 color3;
                
                varying vec2 vUv;

                // Noise function
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    
                    float a = fract(sin(dot(i, vec2(12.9898, 78.233))) * 43758.5453);
                    float b = fract(sin(dot(i + vec2(1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453);
                    float c = fract(sin(dot(i + vec2(0.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);
                    float d = fract(sin(dot(i + vec2(1.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);

                    f = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, f.x) + (c - a) * f.y * (1.0 - f.x) + (d - b) * f.x * f.y;
                }
                
                void main() {
                    vec2 p = (vUv - 0.5) * 2.0;
                    float r = length(p);
                    float angle = atan(p.y, p.x);
                    
                    // Create 8-fold symmetry
                    float segments = 8.0;
                    angle = mod(angle + time * 0.2, 2.0 * 3.14159 / segments);
                    angle = abs(angle - 3.14159 / segments);
                    
                    // Create patterns
                    float pattern1 = sin(r * 10.0 - time) * 0.5 + 0.5;
                    float pattern2 = cos(angle * 5.0 + r * 5.0 - time * 0.5) * 0.5 + 0.5;
                    float pattern3 = sin(r * 15.0 + angle * 3.0 + time * 0.3) * 0.5 + 0.5;
                    
                    // Mix colors based on patterns
                    vec3 finalColor = mix(color1, color2, pattern1);
                    finalColor = mix(finalColor, color3, pattern2 * pattern3);
                    
                    // Create noisy fade for intensity
                    vec2 noiseCoord = p * 3.0 + time * 0.5;
                    float noiseVal = noise(noiseCoord) * 0.5 + 0.5;
                    float noisyIntensity = intensity * (0.8 + 0.2 * noiseVal);
                    
                    // Basic falloff from center
                    float falloff = 1.0 - pow(r, 1.5);
                    
                    gl_FragColor = vec4(finalColor, falloff * noisyIntensity * 0.25);
                }
            `;

            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const backgroundMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    intensity: { value: 0.0 }, // Start with 0 intensity
                    color1: { value: new THREE.Color(colors[0]) },
                    color2: { value: new THREE.Color(colors[1]) },
                    color3: { value: new THREE.Color(colors[2]) }
                },
                fragmentShader,
                vertexShader,
                transparent: true,
                depthWrite: false
            });

            const backgroundGeometry = new THREE.PlaneGeometry(2.3, 4.6);
            backgroundMesh = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
            backgroundMesh.position.z = -1;
            backgroundScene.add(backgroundMesh);
        }

        // Add this new function to handle background intensity
        let targetIntensity = 0;
        let currentIntensity = 0;

        function updateBackgroundIntensity() {
            // Smooth transition of intensity
            const transitionSpeed = 0.01;
            currentIntensity += (targetIntensity - currentIntensity) * transitionSpeed;
            
            if (backgroundMesh) {
                backgroundMesh.material.uniforms.intensity.value = currentIntensity;
            }
        }

        function init() {
            // Initialize main scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false; // Important for rendering background
            document.body.appendChild(renderer.domElement);

            // Create kaleidoscope background
            createKaleidoscopeBackground();

            // Create geometry
            geometry = new THREE.IcosahedronGeometry(0.5, 3);
            
            material = new THREE.MeshPhongMaterial({
                color: colors[0],
                flatShading: true,
                shininess: 50,
                transparent: true,
                opacity: 1.0 // Make the ball slightly transparent
            });

            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Store original vertex positions
            geometry.userData = {
                originalPositions: geometry.attributes.position.array.slice()
            };

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            // Create dynamic lights
            for (let i = 0; i < 4; i++) {
                const light = new THREE.PointLight(colors[i], 0.5, 10);
                light.position.set(
                    Math.cos(i * Math.PI/2) * 3,
                    Math.sin(i * Math.PI/2) * 3,
                    0
                );
                lights.push(light);
                scene.add(light);
            }

            camera.position.z = 4;
        }

        function initializeAudio() {
            if (!audioElement) {
                audioElement = document.createElement('audio');
                audioElement.src = 'wt7.wav';
                audioElement.style.display = 'none';
                document.body.appendChild(audioElement);

                // Initialize AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(audioElement);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                // Add ended event listener
                audioElement.addEventListener('ended', function() {
                    const playPauseButton = document.getElementById('playPause');
                    playPauseButton.textContent = '▶';
                    targetIntensity = 0.0;
                });
            }
        }

        document.getElementById('playPause').addEventListener('click', function() {
            // Initialize audio on first click
            if (!audioElement) {
                initializeAudio();
            }

            // Resume AudioContext if it's suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (audioElement.paused) {
                fadeIn(audioElement);
                this.textContent = '❚❚';
                targetIntensity = 1.0;
            } else {
                fadeOut(audioElement);
                this.textContent = '▶';
                targetIntensity = 0.0;
            }
        });

        let colorIndex = 0;
        let colorTransitionTime = 0;
        let time = 0;

        function getAverageFrequency() {
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            return sum / (dataArray.length * 255); // Normalize to 0-1
        }

        function fadeIn(audio) {
            const fadeDuration = 0.3; // seconds
            audio.volume = 0;
            audio.play();
            let startTime = audio.currentTime;
            const fadeInterval = setInterval(() => {
                const elapsedTime = audio.currentTime - startTime;
                audio.volume = Math.min(elapsedTime / fadeDuration, 1);
                if (audio.volume === 1) {
                    clearInterval(fadeInterval);
                }
            }, 30);
        }

        function fadeOut(audio) {
            const fadeDuration = 0.3; // seconds
            let startTime = audio.currentTime;
            const initialVolume = audio.volume;
            const fadeInterval = setInterval(() => {
                const elapsedTime = audio.currentTime - startTime;
                audio.volume = Math.max(initialVolume - (elapsedTime / fadeDuration), 0);
                if (audio.volume === 0) {
                    audio.pause();
                    clearInterval(fadeInterval);
                }
            }, 30);
        }

        function updateConstantAnimation() {
            // Simple rotation
            mesh.rotation.x += 0.001;
            mesh.rotation.y += 0.002;

            // Update background
            if (backgroundMesh) {
                backgroundMesh.material.uniforms.time.value = time;
                // Slowly cycle through colors
                const colorIndex1 = Math.floor(time * 0.1) % colors.length;
                const colorIndex2 = (colorIndex1 + 1) % colors.length;
                const colorIndex3 = (colorIndex2 + 1) % colors.length;
                backgroundMesh.material.uniforms.color1.value = colors[colorIndex1];
                backgroundMesh.material.uniforms.color2.value = colors[colorIndex2];
                backgroundMesh.material.uniforms.color3.value = colors[colorIndex3];
            }

            // Gentle light movement when paused
            lights.forEach((light, i) => {
                const angle = time * 0.5 + (i * Math.PI/2);
                const radius = 3 + Math.sin(time) * 0.3;
                light.position.x = Math.cos(angle) * radius;
                light.position.y = Math.sin(angle) * radius;
                light.intensity = 0.5;
            });

            // Slow color transition when paused
            colorTransitionTime += 0.001;
            if (colorTransitionTime >= 1) {
                colorTransitionTime = 0;
                colorIndex = (colorIndex + 1) % colors.length;
                material.color.copy(colors[colorIndex]);
            }
        }


        function updateAudioReactiveAnimation() {
            if (!analyser || !dataArray) return;
            
            analyser.getByteFrequencyData(dataArray);
            const avgFreq = getAverageFrequency();

            const positions = geometry.attributes.position.array;
            const originalPositions = geometry.userData.originalPositions;

            // Enhanced audio-reactive deformations
            for (let i = 0; i < positions.length; i += 3) {
                const originalX = originalPositions[i];
                const originalY = originalPositions[i + 1];
                const originalZ = originalPositions[i + 2];

                const distanceFromCenter = Math.sqrt(
                    originalX * originalX + 
                    originalY * originalY + 
                    originalZ * originalZ
                );

                const angle = Math.atan2(originalY, originalX);
                
                const wave = Math.sin(angle * 6 + time * 2) * 0.7;
                const pulse = Math.sin(distanceFromCenter * 5 - time * 3) * 0.9;
                const spiral = Math.sin(angle + distanceFromCenter * 4 + time) * 0.2;
                
                const maxDeformation = 0.7;
                const deformation = Math.max(-maxDeformation, 
                                          Math.min(maxDeformation, 
                                                 (wave + pulse + spiral) * avgFreq * 2));

                positions[i] = originalX * (1 + deformation);
                positions[i + 1] = originalY * (1 + deformation);
                positions[i + 2] = originalZ * (1 + deformation);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();

            // Audio-reactive light intensity
            lights.forEach(light => {
                light.intensity = 0.5 + avgFreq * 0.5 * 8;
            });

            // Faster color transitions with audio
            colorTransitionTime += avgFreq * 0.1;
            if (colorTransitionTime >= 1) {
                colorTransitionTime = 0;
                colorIndex = (colorIndex + 1) % colors.length;
                material.color.copy(colors[colorIndex]);
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            updateBackgroundIntensity();

            // Clear everything
            renderer.clear();

            // Render background first
            renderer.clearDepth();
            renderer.render(backgroundScene, backgroundCamera);
            
            // Clear depth buffer but keep color buffer
            renderer.clearDepth();

            updateConstantAnimation();
            
            if (analyser && audioElement && !audioElement.paused) {
                updateAudioReactiveAnimation();
            }

            // Render main scene
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        animate();
    </script>
</body>
</html>